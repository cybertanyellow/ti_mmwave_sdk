<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Vector Utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Vector Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>The misc. routines for vector arithmetic.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a0caca055eef56c597d066bef6f3167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga7a0caca055eef56c597d066bef6f3167">mmwavelib_accum16</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga7a0caca055eef56c597d066bef6f3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accum16 accumlates input vector to the output vector. It is the optimized implementation of the for loop: for ( idx=0; idx&lt;len; idx++ ) { out[idx] += inp[idx];//addition saturated to 0xFFFF }.  <a href="#ga7a0caca055eef56c597d066bef6f3167">More...</a><br /></td></tr>
<tr class="separator:ga7a0caca055eef56c597d066bef6f3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048b44d24170630317ca0b1589a285af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga048b44d24170630317ca0b1589a285af">mmwavelib_accumPowerFltpAllAnt</a> (uint32_t fftSize, int32_t numAnt, float32_t *inputPtr, float32_t *outputPtr)</td></tr>
<tr class="memdesc:ga048b44d24170630317ca0b1589a285af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accumPowerFltpAllAnt accumulates number of fftSize signal power over all antenna. It can be called per range bin or dopper bin.  <a href="#ga048b44d24170630317ca0b1589a285af">More...</a><br /></td></tr>
<tr class="separator:ga048b44d24170630317ca0b1589a285af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac73796cc03472f1c27897d572c2c8322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gac73796cc03472f1c27897d572c2c8322">mmwavelib_accumPowerFltp</a> (uint32_t length, int32_t accumFlag, float32_t *inputPtr, float32_t *outputPtr)</td></tr>
<tr class="memdesc:gac73796cc03472f1c27897d572c2c8322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accumPowerFltp accumulates signal power of the input signal .  <a href="#gac73796cc03472f1c27897d572c2c8322">More...</a><br /></td></tr>
<tr class="separator:gac73796cc03472f1c27897d572c2c8322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3abbe77f0716d7a664d3b517281034c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga3abbe77f0716d7a664d3b517281034c4">mmwavelib_vecsubc</a> (int16_t *restrict input, int16_t *restrict output, const uint32_t subval, int32_t ncplx)</td></tr>
<tr class="memdesc:ga3abbe77f0716d7a664d3b517281034c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsubc.  <a href="#ga3abbe77f0716d7a664d3b517281034c4">More...</a><br /></td></tr>
<tr class="separator:ga3abbe77f0716d7a664d3b517281034c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629b301147256390e4b0fd894df8c089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga629b301147256390e4b0fd894df8c089">mmwavelib_vecsum</a> (const int16_t input[restrict], int32_t output[restrict], int32_t ncplx)</td></tr>
<tr class="memdesc:ga629b301147256390e4b0fd894df8c089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsum.  <a href="#ga629b301147256390e4b0fd894df8c089">More...</a><br /></td></tr>
<tr class="separator:ga629b301147256390e4b0fd894df8c089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gaf66af7cbc8b38fd72a0077a3eae305d3">mmwavelib_vecsumabs</a> (const int16_t input[], int32_t len)</td></tr>
<tr class="memdesc:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsumabs.  <a href="#gaf66af7cbc8b38fd72a0077a3eae305d3">More...</a><br /></td></tr>
<tr class="separator:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef502b1920c086d1e12483276ec4181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga9ef502b1920c086d1e12483276ec4181">mmwavelib_vecmul16x16</a> (int16_t *restrict x, const int16_t *restrict w, uint32_t nx)</td></tr>
<tr class="memdesc:ga9ef502b1920c086d1e12483276ec4181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function multiply two 16-bit complex vectors element by element. The math is as follows: for ( i=0; i &lt; nx; i++) { outreal[i] = sat((inreal[i]*wreal[i]-inimag[i]*wimag[i]+0x4000)*2)/2^16; outimag[i] = sat((inreal[i]*wimag[i]+inimag[i]*wreal[i]+0x4000)*2)/2^16; }.  <a href="#ga9ef502b1920c086d1e12483276ec4181">More...</a><br /></td></tr>
<tr class="separator:ga9ef502b1920c086d1e12483276ec4181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b5ffe708b678af97514c34b46b8d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga05b5ffe708b678af97514c34b46b8d47">mmwavelib_vecmul16x32</a> (const int16_t *restrict x, const int32_t *restrict w, int32_t *restrict y, uint32_t nx)</td></tr>
<tr class="memdesc:ga05b5ffe708b678af97514c34b46b8d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }.  <a href="#ga05b5ffe708b678af97514c34b46b8d47">More...</a><br /></td></tr>
<tr class="separator:ga05b5ffe708b678af97514c34b46b8d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga272359269ae91ec99cc4bdf2bf1b6ddd">mmwavelib_shiftright16</a> (int16_t input[restrict], int16_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 16-bit element in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }.  <a href="#ga272359269ae91ec99cc4bdf2bf1b6ddd">More...</a><br /></td></tr>
<tr class="separator:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gace3a5c0cc0ff8f08dfa600b23f5a15f0">mmwavelib_shiftright32</a> (int32_t input[restrict], int32_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 32-bit word in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }.  <a href="#gace3a5c0cc0ff8f08dfa600b23f5a15f0">More...</a><br /></td></tr>
<tr class="separator:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296a4ffed31c9015b34581b6712dc0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga296a4ffed31c9015b34581b6712dc0cf">mmwavelib_histogram</a> (uint16_t input[restrict], uint16_t hist[restrict], uint16_t histTemp[restrict], uint32_t inpLen, uint32_t histLen, uint8_t numshift)</td></tr>
<tr class="memdesc:ga296a4ffed31c9015b34581b6712dc0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function calculates the histogram of the right-shifted input array The math is as follows: for ( i=0; i &lt; len; i++) { hist[input[i]&gt;&gt;k] ++; }.  <a href="#ga296a4ffed31c9015b34581b6712dc0cf">More...</a><br /></td></tr>
<tr class="separator:ga296a4ffed31c9015b34581b6712dc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c76050f4862b78d1f05325be3a4237"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gac8c76050f4862b78d1f05325be3a4237">mmwavelib_maxpow</a> (const int32_t *restrict input, int32_t Ncplx, float32_t *maxpow)</td></tr>
<tr class="memdesc:gac8c76050f4862b78d1f05325be3a4237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_maxpow.  <a href="#gac8c76050f4862b78d1f05325be3a4237">More...</a><br /></td></tr>
<tr class="separator:gac8c76050f4862b78d1f05325be3a4237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The misc. routines for vector arithmetic. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7a0caca055eef56c597d066bef6f3167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accum16 </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function mmwavelib_accum16 accumlates input vector to the output vector. It is the optimized implementation of the for loop: for ( idx=0; idx&lt;len; idx++ ) { out[idx] += inp[idx];//addition saturated to 0xFFFF }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input vector of 16-bit samples </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>: output vector of 16-bit samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of samples in vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input and output arrays both are 8 byte alligned </dd>
<dd>
(2)Array length (len) is a multiple of 4</dd></dl>
<p>Cycles 1.1N+40 </p>

</div>
</div>
<a class="anchor" id="gac73796cc03472f1c27897d572c2c8322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accumPowerFltp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>accumFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>inputPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>outputPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function mmwavelib_accumPowerFltp accumulates signal power of the input signal . </p>
<hr/>
<p> if (accumFlag==0) { for (j = 0; j &lt; length; j++) outputPtr[j]=inputPtr[2*j]^2+inputPtr[2*j+1]^2; } else //accuFlag !=0 { for (j = 0; j &lt; length; j++) outputPtr[j]+=(inputPtr[2*j]^2+inputPtr[2*j+1]^2); }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Input complex signal length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accumFlag</td><td>: if 0, initialize the output as the input signal power if not 0, accumulate the input signal power to output power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPtr</td><td>: floating-point I/Q complex signal input, size of length*2, Must be aligned to 8-byte boundary. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputPtr</td><td>: accumulated power output (non-coherent combining). Must be aligned to 8-byte boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)inputPtr and outputPtr arrays both are 8 byte alligned</dd></dl>
<p>Cycles (cgt 8.1.3) 1) accumFlag=0, 1*length+36 2) accumFlag!=0, 1.5*length+49</p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ga048b44d24170630317ca0b1589a285af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accumPowerFltpAllAnt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fftSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>numAnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>inputPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>outputPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function mmwavelib_accumPowerFltpAllAnt accumulates number of fftSize signal power over all antenna. It can be called per range bin or dopper bin. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fftSize</td><td>: Input FFT sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numAnt</td><td>: number of accumulated RX antennas. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPtr</td><td>: floating-point I/Q complex signal input, size of fftSize*2*numAnt the data is stored one antenna after another. Must be aligned to 8-byte boundary. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputPtr</td><td>: accumulated power output (non-coherent combining). Must be aligned to 8-byte boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)inputPtr and outputPtr arrays both are 8 byte alligned</dd></dl>
<p>Cycles L1P and L1D cache is set to 32K. Input and output are all floating point version. (8.1.3) 1 Antenna: 1*fftsize+61, 2 Antenna: 2.5*fftsize+90, except 1024 with 4224 4 Antenna: 4.08*fftsize+53 except 1024 with 27076 8 Antenna: 9.16*fftsize+61, except 512 with 39526, and 1024 with 83316 </p>

</div>
</div>
<a class="anchor" id="ga296a4ffed31c9015b34581b6712dc0cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_histogram </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hist</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>histTemp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inpLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>histLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function calculates the histogram of the right-shifted input array The math is as follows: for ( i=0; i &lt; len; i++) { hist[input[i]&gt;&gt;k] ++; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: input array of unsigned 16-bit elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hist</td><td>: output histogram array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">histTemp</td><td>: temp scratch buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpLen</td><td>: number of 16-bit elements in input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">histLen</td><td>: length of historgram, = 1&lt;&lt;(16-numshift) normally. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: number of bits to be right-shifted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and histTemp are 8 byte alligned. </dd>
<dd>
(2)inpLen is multiple of 8, and histLen is multiple of 2. </dd>
<dd>
(3)histTemp buffer's length is 8*histLen.</dd></dl>
<p>Cycles inpLen*1.125 + histLen*2.75 + overhead (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gac8c76050f4862b78d1f05325be3a4237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_maxpow </td>
          <td>(</td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>Ncplx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>maxpow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_maxpow. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Find from 32bit complex vector the maximum sample power(I^2+Q^2), and the index of the corresponding complex sample. The math is as follows: for ( i=0; i &lt; Ncplx; i++) { pow = input[2*i]*input[2*i] + input[2*i+1]*input[2*i+1]; if (pow &gt; max) {maxpow = pow; maxidx = i;} }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array of complex samples (32bit I 32bit Q or vice versa). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ncplx</td><td>: Number of complex elements in input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxpow</td><td>: Output pointer to store the maximum power found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the index of the complex input sample that has the max I^2+Q^2.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input is 8 byte alligned. </dd>
<dd>
(2)Ncplx is a multiple of 2.</dd></dl>
<p>Cycles 1.5*Ncplx + 59 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga272359269ae91ec99cc4bdf2bf1b6ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_shiftright16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function shifts each signed 16-bit element in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: Number of bits to be right-shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 16-bit elements in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte alligned. </dd>
<dd>
(2)len is a multiple of 8.</dd></dl>
<p>Cycles 0.25*len + 32 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gace3a5c0cc0ff8f08dfa600b23f5a15f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_shiftright32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function shifts each signed 32-bit word in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: Number of bits to be right-shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 32-bit words in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte alligned. </dd>
<dd>
(2)len is a multiple of 4.</dd></dl>
<p>Cycles 0.5*len + 32 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga9ef502b1920c086d1e12483276ec4181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecmul16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function multiply two 16-bit complex vectors element by element. The math is as follows: for ( i=0; i &lt; nx; i++) { outreal[i] = sat((inreal[i]*wreal[i]-inimag[i]*wimag[i]+0x4000)*2)/2^16; outimag[i] = sat((inreal[i]*wimag[i]+inimag[i]*wreal[i]+0x4000)*2)/2^16; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>: Input array. Output will be written in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>: The second input array, e.g. the array of windowing coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>: Number of complex elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Arrays are 8 byte alligned. </dd>
<dd>
(2)nx is a multiple of 4. </dd>
<dd>
(3)Imaginary/real components are stored in adjacent locations in the arrays. The imaginary components are stored at even array indices, and the real components are stored at odd array indices.</dd></dl>
<p>Cycles 0.75*nx + 38 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga05b5ffe708b678af97514c34b46b8d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecmul16x32 </td>
          <td>(</td>
          <td class="paramtype">const int16_t *restrict&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: Pointer to 16-bit input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>: Pointer to 32-bit input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>: Pointer to 32-bit output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>Number of complex elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output arrays are 8 byte alligned. </dd>
<dd>
(2)nx is a multiple of 4. </dd>
<dd>
(3)Input x,w: The imaginary components are stored at even array indices, and the real components are stored at odd array indices. Output y: The real components are stored at even array indices, and the imaginary components are stored at odd array indices.</dd></dl>
<p>Cycles 1.5*nx + 43 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga3abbe77f0716d7a664d3b517281034c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecsubc </td>
          <td>(</td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>subval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ncplx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsubc. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Subtract const value from each element in 16-bit complex vector. The math is as follows: output_real[n]= input_real[n] - subval_real; output_imag[n]= input_imag[n] - subval_imag; The function can be used for 16-bit real vector too, by simply pack two subval_real in 32-bit subval.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: pointer to input array (e.g. 16bit I followed by 16bit Q) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: pointer to output, can be the same array as input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subval</td><td>: Packed value to be subtracted (e.g. Q in high 16, I in low 16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncplx</td><td>: Number of complex elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output 8 byte alligned. </dd>
<dd>
(2)ncplx is a multiple of 4.</dd></dl>
<p>Cycles 0.5*Ncplx + ovh (0.25*NumOf16bitElements + ovh), ovh=~40 cgt8.1.3 </p>

</div>
</div>
<a class="anchor" id="ga629b301147256390e4b0fd894df8c089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecsum </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ncplx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsum. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Sum the elements in 16-bit complex vector. The math is as follows: for ( i=0; i &lt; ncplx; i++) { output[0] += input[2*i]; output[1] += input[2*i+1]; } The order of I&amp;Q in output is same as that in input. The function can be used for 16-bit real vector too, and user can simply do output[0]+output[1] after the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input complex array (e.g.16bit I followed by 16bit Q each). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncplx</td><td>: Number of complex elements in input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output sum (e.g. 32bit sum I followed by 32bit sum Q).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte alligned. </dd>
<dd>
(2)Number of complex elements is a multiple of 4.</dd></dl>
<p>Cycles 0.5*Ncplx + ovh (0.25*NumOf16bitElements + ovh), ovh=~30 cgt8.1.3 </p>

</div>
</div>
<a class="anchor" id="gaf66af7cbc8b38fd72a0077a3eae305d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_vecsumabs </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsumabs. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Sum the absolute values of 16-bit elements in vector. The math is as follows: for ( i=0; i &lt; len; i++) { sum += abs(input[i]); }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 16-bit elements in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the 32-bit sum</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input is 8 byte alligned. </dd>
<dd>
(2)len is a multiple of 4.</dd></dl>
<p>Cycles 0.25*len + ovh, ovh=37 cgt8.1.3 </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
