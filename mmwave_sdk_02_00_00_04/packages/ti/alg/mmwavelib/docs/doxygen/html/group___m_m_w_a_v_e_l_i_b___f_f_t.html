<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FFT Utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FFT Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>The functions facilitate stage wise FFT.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0f58e1c7dfd8ffa5c37aa3a012e5414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gad0f58e1c7dfd8ffa5c37aa3a012e5414">mmwavelib_dftSingleBin</a> (const uint32_t inBuf[restrict], const uint32_t sincos[restrict], uint64_t *restrict output, uint32_t length, uint32_t doppInd)</td></tr>
<tr class="memdesc:gad0f58e1c7dfd8ffa5c37aa3a012e5414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dftSingleBin.  <a href="#gad0f58e1c7dfd8ffa5c37aa3a012e5414">More...</a><br /></td></tr>
<tr class="separator:gad0f58e1c7dfd8ffa5c37aa3a012e5414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ac54ea25984994384c660c9d2ba1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga09ac54ea25984994384c660c9d2ba1f8">mmwavelib_dftSingleBinWithWindow</a> (const uint32_t inBuf[restrict], const uint32_t sincos[restrict], const int32_t win[restrict], uint64_t *restrict output, uint32_t length, uint32_t doppInd)</td></tr>
<tr class="memdesc:ga09ac54ea25984994384c660c9d2ba1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dftSingleBinWithWindow.  <a href="#ga09ac54ea25984994384c660c9d2ba1f8">More...</a><br /></td></tr>
<tr class="separator:ga09ac54ea25984994384c660c9d2ba1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2de8e6b5ed556d0456cba95a15110cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gac2de8e6b5ed556d0456cba95a15110cc">mmwavelib_fft16ptZeroPadded32x32</a> (const int32_t *restrict inp, const int32_t *restrict twiddle, int32_t *restrict temp, int32_t *restrict out, uint32_t numLines, uint32_t numSkipSamples)</td></tr>
<tr class="memdesc:gac2de8e6b5ed556d0456cba95a15110cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">mmwavelib_fft16ptZeroPadded32x32 Computes the 16pt FFT of vectors of length 8. The input vectors are assumed to be in transpose format (in inp). Hence the FFT can be thought of as operating along the columns of inp  <a href="#gac2de8e6b5ed556d0456cba95a15110cc">More...</a><br /></td></tr>
<tr class="separator:gac2de8e6b5ed556d0456cba95a15110cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e93be64cedae950adb6a15e9bb1c08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga4e93be64cedae950adb6a15e9bb1c08b">mmwavelib_windowing16x16</a> (int16_t inp[restrict], const int16_t win[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga4e93be64cedae950adb6a15e9bb1c08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16xl6.  <a href="#ga4e93be64cedae950adb6a15e9bb1c08b">More...</a><br /></td></tr>
<tr class="separator:ga4e93be64cedae950adb6a15e9bb1c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03eec284913bf5a1a4508f87b0d5c570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga03eec284913bf5a1a4508f87b0d5c570">mmwavelib_windowing16x32</a> (const int16_t inp[restrict], const int32_t win[restrict], int32_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga03eec284913bf5a1a4508f87b0d5c570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16x32.  <a href="#ga03eec284913bf5a1a4508f87b0d5c570">More...</a><br /></td></tr>
<tr class="separator:ga03eec284913bf5a1a4508f87b0d5c570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424bff8de82528e9318cd24995aa0fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga424bff8de82528e9318cd24995aa0fba">mmwavelib_windowing16x16_evenlen</a> (int16_t inp[restrict], const int16_t win[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga424bff8de82528e9318cd24995aa0fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16xl6_evenlen.  <a href="#ga424bff8de82528e9318cd24995aa0fba">More...</a><br /></td></tr>
<tr class="separator:ga424bff8de82528e9318cd24995aa0fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The functions facilitate stage wise FFT. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad0f58e1c7dfd8ffa5c37aa3a012e5414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dftSingleBin </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>inBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sincos</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doppInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dftSingleBin. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculates single bin DFT. for (i = 0; i &lt; length; i++) outputComplex += inputComplex(i)*exp(-j*2*pi*i*doppInd/length);</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuf</td><td>: Input int16 real, int16 imaginary complex array, Real part is at low 16 bits, imaginary part is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sincos</td><td>: Table with sine cosine values for exp(-1j*2*pi*k/N) Sine is at low 16 bits, cosine is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Single point DFT value, int32 real in lower half of 64bit, int32 imaginary in higher half. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Length of input buffer (size of DFT) must be multiple of 4</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doppInd</td><td>: Index value at wich the DFT is calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1) inBuf must be 8 byte aligned. </dd>
<dd>
(2) length must be multiple of 4.</dd></dl>
<p>Cycles length/4*5 + 76 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga09ac54ea25984994384c660c9d2ba1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dftSingleBinWithWindow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>inBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sincos</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doppInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dftSingleBinWithWindow. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculates single bin DFT with windowing. <pre class="fragment">                     for (i = 0; i &lt; length; i++)
                        outputComplex +=  inputComplex(i)*win(i)*exp(-j*2*pi*i*doppInd/length);
</pre></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuf</td><td>: Input int16 real, int16 imaginary complex array, Real part is at low 16 bits, imaginary part is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sincos</td><td>: Table with sine cosine values for exp(-1j*2*pi*k/N) Sine is at low 16 bits, cosine is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Window real array (32 bit) of length length/2 (since its a symmetric window)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Single point DFT value, int32 real in lower half of 64bit, int32 imaginary in higher half. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Length of input buffer (size of DFT) must be multiple of 4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doppInd</td><td>: Index value at which the DFT is calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1) inBuf and win must be 8 byte aligned. </dd>
<dd>
(2) length must be multiple of 4.</dd></dl>
<p>Cycles length/4*7 + 58 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="gac2de8e6b5ed556d0456cba95a15110cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_fft16ptZeroPadded32x32 </td>
          <td>(</td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>twiddle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSkipSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mmwavelib_fft16ptZeroPadded32x32 Computes the 16pt FFT of vectors of length 8. The input vectors are assumed to be in transpose format (in inp). Hence the FFT can be thought of as operating along the columns of inp </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input complex array (32 bit I, 32 bit Q). The input array is assumed to be a x[8][numLines*2] array, *2 is for complex, with each FFT operating along each columns resultingin an ouput of length 16. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">twiddle</td><td>: twiddle factors array (32 bit I, 32 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>: temporary buffer (sufficient to store 16*numLines complex samples) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output complex array (32 bit I, 32 bit Q) (size: out[numLines][16*2]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLines</td><td>: number of consecutive columns of inp for which the FFT must be run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSkipSamples</td><td>: number of total columns L of inp if L&gt;numLines. otherwise this equals to numLines.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input array (inp), output array (out), twiddle factor array (twiddle), temp buffer (temp) are all 8 byte alligned </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e93be64cedae950adb6a15e9bb1c08b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16xl6. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 16 bit real windowing vector. The rounded result is stored inplace. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16bit Q). Output is written inplace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (16 bit) of length len/2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp) and Windowing array (win) are all 8 byte alligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 8. </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 0.59375*len +54 </p>

</div>
</div>
<a class="anchor" id="ga424bff8de82528e9318cd24995aa0fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x16_evenlen </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16xl6_evenlen. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 16 bit real windowing vector. The rounded result is stored inplace. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16bit Q). Output is written inplace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (16 bit) of length len/2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp) and Windowing array (win) are all 8 byte alligned. </dd>
<dd>
(2)Input array length (len) is multiple of 2. </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 0.59375*len + ovh; len%16=0: ovh=~79; len%16=6,8,14: ovh=~88; 0.6548 *len + ovh; len%16=2,4: ovh=~82; len%16=10,12: ovh=~90. </p>

</div>
</div>
<a class="anchor" id="ga03eec284913bf5a1a4508f87b0d5c570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x32 </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16x32. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 32 bit real symmetric window vector . The result is stored as a 32 bit complex vector. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (32 bit) of length len/2 (since its a symmetric window) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: Output complex array (32 bit I followed by 32 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp), Output (win) and Windowing array (win) are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 4 </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 1.25*len +47 </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
